from Crypto.Util.number import *
import primefac
n = 93248973505443788452259459407305483848562453677011537370774729667743195163854315191719127168690404915990498148604581445462554571259234967629881681567112965898878450613390793275809215660624314254099992688747881377199022267293373693461668684760337870624355204574117608172988533101874703532686392160101281812581
c = 63310881467934924174308883794737118541624715823542893832959954020648488759570933310365426532720541198480834044941208789526518773611716692659122492920641621010677016366172054690284863296209475401569489521567650143626592660488001988154460319320589098034341592548000317494143932818389020926717018955465965071504


e=33213207961299640112614765733787993938748422107338140555189372148541833149422234807137030055789083951369673088937122524595639423416479951493940134241354862963838348195594859712757134597151816289659519695289812206969825415098595565736332132260827091863092036068738783641206030633008469024411408931803376637847
def pollard_pm1(n, B1=100, B2=1000):
    from _primefac._arith import ispower, gcd, ilog
    from _primefac._prime import isprime, primegen
    import six
    if isprime(n):
        return n
    m = ispower(n)
    if m:
        return m
    while True:
        pg = primegen()
        q = 2           # TODO: what about other initial values of q?
        p = six.next(pg)
        while p <= B1:
            q, p = pow(q, p**ilog(B1, p), n), six.next(pg)
        g = gcd(q-1, n)
        if 1 < g < n:
            return g
        while p <= B2:
            q, p = pow(q, p, n), six.next(pg)
        g = gcd(q-1, n)
        if 1 < g < n:
            return g
        # These bounds failed.  Increase and try again.
        B1 *= 10
        B2 *= 10
q = pollard_pm1(n)
p = n//q
phi=(p-1)*(q-1)
d=inverse(e,phi)
flag =pow(c,d,n)
print(long_to_bytes(flag).decode())
print(q)
print(p)
